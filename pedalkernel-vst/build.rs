//! Build script to auto-discover .pedal files from pedalkernel-pro and main repo.
//!
//! This eliminates the need to manually list pedals in lib.rs.
//! Pedals are categorized based on their directory:
//! - overdrive/, wah/, fuzz/, distortion/ → PRO_GUITAR_PEDALS
//! - bass/ → PRO_BASS_PEDALS
//! - amp/ → PRO_AMP_PEDALS
//! - synth/ → PRO_SYNTH_PEDALS (VCO/VCF/VCA-based synthesizers)
//! - Everything else (compressor/, chorus/, phaser/, tremolo/, delay/, reverb/) → PRO_SHARED_PEDALS
//!
//! Sources:
//! - pedalkernel-pro/pedals/ (private repo - pro content)
//! - pedalkernel/examples/pedals/ (main repo - open source examples)
//! - pedalkernel/examples/synths/ (main repo - open source synth examples)

use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("pro_pedals.rs");

    // Find pedal directories relative to the workspace root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let pro_pedals_dir = PathBuf::from(&manifest_dir)
        .join("../../pedalkernel-pro/pedals");
    let main_pedals_dir = PathBuf::from(&manifest_dir)
        .join("../pedalkernel/examples/pedals");
    let main_synths_dir = PathBuf::from(&manifest_dir)
        .join("../pedalkernel/examples/synths");

    // Check if pedal directories exist
    let pro_exists = pro_pedals_dir.exists();
    let main_exists = main_pedals_dir.exists();
    let main_synths_exists = main_synths_dir.exists();

    // Tell cargo to rerun if the pedals directories change
    for (exists, pedals_dir) in [(pro_exists, &pro_pedals_dir), (main_exists, &main_pedals_dir), (main_synths_exists, &main_synths_dir)] {
        if exists {
            println!("cargo:rerun-if-changed={}", pedals_dir.display());
            // Also watch individual pedal files
            if let Ok(entries) = fs::read_dir(pedals_dir) {
                for entry in entries.filter_map(|e| e.ok()) {
                    let path = entry.path();
                    if path.is_dir() {
                        println!("cargo:rerun-if-changed={}", path.display());
                    } else if path.extension().map_or(false, |e| e == "pedal") {
                        println!("cargo:rerun-if-changed={}", path.display());
                    }
                }
            }
        }
    }

    let mut output = String::new();

    output.push_str("// Auto-generated by build.rs - do not edit manually\n\n");

    if !pro_exists && !main_exists && !main_synths_exists {
        // No pedals available - generate empty arrays
        output.push_str("#[cfg(feature = \"pro-amps\")]\n");
        output.push_str("const PRO_AMP_PEDALS: &[&str] = &[];\n\n");
        output.push_str("#[cfg(feature = \"pro-guitar\")]\n");
        output.push_str("const PRO_GUITAR_PEDALS: &[&str] = &[];\n\n");
        output.push_str("#[cfg(feature = \"pro-bass\")]\n");
        output.push_str("const PRO_BASS_PEDALS: &[&str] = &[];\n\n");
        output.push_str("#[cfg(feature = \"pro-synth\")]\n");
        output.push_str("const PRO_SYNTH_PEDALS: &[&str] = &[];\n\n");
        output.push_str("#[cfg(any(feature = \"pro-guitar\", feature = \"pro-bass\"))]\n");
        output.push_str("const PRO_SHARED_PEDALS: &[&str] = &[];\n\n");
    } else {
        let mut guitar_pedals: Vec<PathBuf> = Vec::new();
        let mut bass_pedals: Vec<PathBuf> = Vec::new();
        let mut amp_pedals: Vec<PathBuf> = Vec::new();
        let mut synth_pedals: Vec<PathBuf> = Vec::new();
        let mut shared_pedals: Vec<PathBuf> = Vec::new();

        // Guitar-specific directories (pedals, not amps)
        let guitar_dirs = ["overdrive", "wah", "fuzz", "distortion"];
        // Bass-specific directories
        let bass_dirs = ["bass"];
        // Amp directories
        let amp_dirs = ["amp"];
        // Synth directories
        let synth_dirs = ["synth"];
        // Shared directories (everything else)
        let shared_dirs = ["compressor", "chorus", "phaser", "tremolo", "delay", "reverb", "modulation", "gate"];

        // Collect from both pro and main repos
        let pedal_sources: Vec<&PathBuf> = [(pro_exists, &pro_pedals_dir), (main_exists, &main_pedals_dir)]
            .iter()
            .filter(|(exists, _)| *exists)
            .map(|(_, dir)| *dir)
            .collect();

        for pedals_dir in &pedal_sources {
            // Collect pedals from subdirectories
            for dir_name in &guitar_dirs {
                collect_pedals(&pedals_dir.join(dir_name), &mut guitar_pedals);
            }
            for dir_name in &bass_dirs {
                collect_pedals(&pedals_dir.join(dir_name), &mut bass_pedals);
            }
            for dir_name in &amp_dirs {
                collect_pedals(&pedals_dir.join(dir_name), &mut amp_pedals);
            }
            for dir_name in &synth_dirs {
                collect_pedals(&pedals_dir.join(dir_name), &mut synth_pedals);
            }
            for dir_name in &shared_dirs {
                collect_pedals(&pedals_dir.join(dir_name), &mut shared_pedals);
            }

            // Also check for pedals in the root pedals/ directory
            if let Ok(entries) = fs::read_dir(pedals_dir) {
                for entry in entries.filter_map(|e| e.ok()) {
                    let path = entry.path();
                    if path.is_file() && path.extension().map_or(false, |e| e == "pedal") {
                        // Root-level pedals go to shared
                        shared_pedals.push(path);
                    }
                }
            }
        }

        // Also collect synths from main repo examples/synths/
        if main_synths_exists {
            collect_pedals(&main_synths_dir, &mut synth_pedals);
        }

        // Sort for deterministic ordering
        guitar_pedals.sort();
        bass_pedals.sort();
        amp_pedals.sort();
        synth_pedals.sort();
        shared_pedals.sort();

        // Generate PRO_AMP_PEDALS
        output.push_str("#[cfg(feature = \"pro-amps\")]\n");
        output.push_str("const PRO_AMP_PEDALS: &[&str] = &[\n");
        for path in &amp_pedals {
            if let Ok(abs_path) = path.canonicalize() {
                output.push_str(&format!("    include_str!(\"{}\"),\n", abs_path.display()));
            }
        }
        output.push_str("];\n\n");

        // Generate PRO_GUITAR_PEDALS (use absolute paths for include_str!)
        output.push_str("#[cfg(feature = \"pro-guitar\")]\n");
        output.push_str("const PRO_GUITAR_PEDALS: &[&str] = &[\n");
        for path in &guitar_pedals {
            // Use canonicalize to get absolute path
            if let Ok(abs_path) = path.canonicalize() {
                output.push_str(&format!("    include_str!(\"{}\"),\n", abs_path.display()));
            }
        }
        output.push_str("];\n\n");

        // Generate PRO_BASS_PEDALS
        output.push_str("#[cfg(feature = \"pro-bass\")]\n");
        output.push_str("const PRO_BASS_PEDALS: &[&str] = &[\n");
        for path in &bass_pedals {
            if let Ok(abs_path) = path.canonicalize() {
                output.push_str(&format!("    include_str!(\"{}\"),\n", abs_path.display()));
            }
        }
        output.push_str("];\n\n");

        // Generate PRO_SYNTH_PEDALS
        output.push_str("#[cfg(feature = \"pro-synth\")]\n");
        output.push_str("const PRO_SYNTH_PEDALS: &[&str] = &[\n");
        for path in &synth_pedals {
            if let Ok(abs_path) = path.canonicalize() {
                output.push_str(&format!("    include_str!(\"{}\"),\n", abs_path.display()));
            }
        }
        output.push_str("];\n\n");

        // Generate PRO_SHARED_PEDALS (only for guitar and bass variants, NOT amps or synth)
        output.push_str("#[cfg(any(feature = \"pro-guitar\", feature = \"pro-bass\"))]\n");
        output.push_str("const PRO_SHARED_PEDALS: &[&str] = &[\n");
        for path in &shared_pedals {
            if let Ok(abs_path) = path.canonicalize() {
                output.push_str(&format!("    include_str!(\"{}\"),\n", abs_path.display()));
            }
        }
        output.push_str("];\n");
    }

    let mut file = fs::File::create(&dest_path).unwrap();
    file.write_all(output.as_bytes()).unwrap();
}

fn collect_pedals(dir: &Path, pedals: &mut Vec<PathBuf>) {
    if !dir.exists() {
        return;
    }

    if let Ok(entries) = fs::read_dir(dir) {
        for entry in entries.filter_map(|e| e.ok()) {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |e| e == "pedal") {
                pedals.push(path);
            }
        }
    }
}
